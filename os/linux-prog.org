[[file:~/resources/os/book/linux_program/linux_system_programming_2nd_edition.pdf][linux programming]]

* File I/O
** File Descriptors
A file descriptor is a non-negative integer. When we want to read or write a file, we
identify the file with the file descriptor that was returned by =open= or =creat= as an
argument to either =read= or =write=.

By convention, UNIX System shells associate file descriptor:
- 0(=STDIN_FILENO=): the standard input of a process
- 1(=STDOUT_FILENO=): the standard output of a process
- 2(=STDERR_FILENO=): the standard error of a process

File descriptors range from 0 through =OPEN_MAX - 1=.
** Opening Files
[[man:open(2)][open(2)]]
*** =open= and =openat= Functions
A file is opened or created by calling either the =open= function or the =openat= function.
#+BEGIN_SRC C
  #include <fcntl.h>
  #include <sys/types.h>
  #include <sys/stat.h>

  int open(const char *path, int oflag, ... /* mode_t mode */ );
  int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );
  // Both return: file descriptor if OK, âˆ’1 on error
#+END_SRC

- =path=: the name of the file to open or create
  - =open=: absolute pathname
  - =openat=: relative pathname
- =oflag=: determines the type of access used, the prefix name is O_* (e.g. =O_RDONLY, O_WRONLY_O_RDWR=)
- =mode_t=: provide the permissions of the newly created file 
- *return*: the file descriptor returned by =open= and =openat= is guaranteed to be the lowest-numbered unused descriptor
- =fd=: is a file descriptor or =AT_FDCWD=
  - file descriptor: specifies the starting location in the file system where the relative pathname is to be evaluated. It is obtained by opening the directory where the relative pathname is to be evaluated.
  - =AT_FDCWD=: current working directory

** Reading
[[man:read(2)]]

size limits on =read=: According to POSIX.1, if count is greater than =SSIZE_MAX=, the result is implementation-defined

** Writing
[[man:write(2)]]
When a user-space application issues a =write()= system call, the Linux kernel performs a few checks and the simply copies the dada into a buffer. Later, in the background, the kernel fathers up all of the dirty buffer, which are buffers that contain data newer than what is on disk, sorts them optimally and writes them out to dist(a process known as *writeback*)

delayed writes has the following problem
- an application may believe that a write has occurred successfully, in the event of a system crash, the data will never make it to disk
- the inability to enforce *write ordering*
- Any I/O error that occurs during writeback cannot be reported back to the process that issued the write request

To ensure that data is written out in a timely manner, the kernel institutes a *maximum buffer age* and write out all dirty buffers before they mature past the given value. Users can configure this value via =/proc/sys/vm/dirty_expire_centisecs= (one hundredths of a second)

** Synchronized I/O
<<synchronized_I/O>>
[[man:fsync(2)]]
=fdatasync= is similar to =fsync=, but does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be  correctly handled, *so =datasync= is an easy performance win*.

Neither function guarantees that any updated directory entries containing the file are synchronized to disk. To ensure that any updates to the directory entry are also committed to disk, =fsync= must also be called on a file descriptor opened against the file's directory.

[[man:sync(2)]]
commit filesystem caches to disk

oflag:
- =O_SYNC=: an implicit =fsync=, but performance lower than =fsync=
- =O_DSYNC=: an implicit =fdatasync=, but performance lower than =fdatasync=
- =O_RSYNC=: 

** Direct I/O
Providing the =O_DIRECT= flag to =open()= instructs the kernel to minimize the presence of I/O management. When this flag is provided, I/O will initiate directly from user-space buffers to the device, bypassing the page cache. All I/O will be synchronous; operations will not return until completed.

When performing direct I/o, the request length, buffer alignment, and file offsets must all be integer multiples of the underlying device's sector size---generally, this is 512 bytes. To remain compatible, applications should align to the larger logical block size.

** Closing Files
[[man:close(2)]]
After a program has finished working with a file descriptor, it can unmap the file descriptor from the associated file via the =close()= system call.

Note: Typically, filesystem do not flush buffers when a closed. If you need to be sure that the data is physically stored on the underlying disk, use [[synchronized_I/O]]

** Seeking
[[man:lseek(2)]]

Seeking past the end of a file dose nothing
- read request: return =EOF=
- write request: new space will be created between the old length of the file and the new length, and it will be padded with zeros.
  This zero padding is called a *hole*. On Unix-style filesystems, holes do not occupy any physical disk space. This implies that This implies that the total size of all files on a file system can add up to more than the physical size of the disk. Files with holes are called *spares files*. Sparse files can save considerable space and enhance performance because manipulating the holes dose not initiate any physical I/O.
  A read request to the part of a file in a hole will return the appropriate number of zeros.

** Positional Reads and Writes
[[man:pread(2)]]
- these calls are easier to use
- they do note update the file pointer upon completion
- they avoid any potential races that might occur when using =lseek= (e.g., race conditions can be avoided )

** Truncating Files
[[man:truncate(2)]]

** Multiplexed I/O
[[man:select(2)]]
[[man:poll(2)]]

* Buffered I/O
- block is an abstraction representing the smallest unit of storage on a filesystem. Inside the kernel, all filesystem operations occur in terms of blocks.
- =user-buffer I/O=: a way for applications to read and write data in whatever amounts fell natural but have the actual I/O occur in units of the filesystem block size.
- block size: blocks are usually 512, 1024, 2048, 4096, or 8192 bytes in size.

** Opening Files
[[man:fopen(3)]]
** Closing Streams
[[man:fclose(3)]]
[[man:fcloseall(3)]]

** Reading from a Stream
[[man:fgetc(3)]]
[[man:fread(3)]]

** Writing to a Stream
[[man:fputc(3)]]
[[man:fwrite(3)]]

** Seeking a Stream
[[man:fseek(3)]]
** Flushing a Stream
[[man:fflush(3)]]
=fflush()= merely writes the user-buffered data out to the kernel buffer. The effect is the same as if user buffer was not employed and write() was used directly.
So, For writing user-buffered directly to the hard disk, you can call =fflush()=, followed immediately by =fsync()=.

** Errors and End-of-file
[[man:ferror(3)]]

** Obtaining the Associated File Descriptor
[[man:fileno(3)]]

** Controlling the Buffering
[[man:setbuf(3)]]
Standard I/O implements three types of user buffering and provides developers with an interface for controlling the type and size of the buffer.
- Unbuffered(=_IONBF=): No user buffering is performed.
  Date is submitted directly to the kernel. As this disables user buffering, negating any benefit, this option is not commonly used, with a lone exception: standard error, by default, is unbuffered.
- Line-buffered(=_IOLBF=):  Buffering is performed on a per-line basis.
  *With each newline character, the buffer is submitted to the kernel*. Line buffering makes sense for streams being output to the screen, since messages printed to the screen are delimited with newlines.
- Block-buffered(=_IOFBF=): Buffering is performed on a per-block basis, where a block is a fixed number of bytes.
  By default, all streams associated with files are block-buffered. Standard I/o uses the term full buffering for block buffering.

Note:
=setvbuf=: 
- must be called after opening the stream but before any other operations have been performed  on it.
- The supplied buffer, if any, must exits when the stream is closed. A common mistake is to declare the buffer as an automatic variable in a scope that ends before the stream is closed.

** Thread Safety
The standard I/o functions are inherently thread-safe.

*** Manual File Locking
[[man:flockfile(3)]]

*** Unlocked Stream Operations
[[man:unlocked_stdio(3)]]
There is a second reason or performing manual locking on streams. With the finergrained and more precise control of locking that only the application programmer can provide, it might be possible to minimize the over head of locking and to improve performance.

** Critiques of Standard I/O
* Advanced File I/O
** Scatter/gather I/O
Allows a single call to read from or write data to many buffers at once; useful for bunching together fields of different data structures to from one I/O transaction.
[[man:readv(2)]]

optimizing the count:
During a vectored I/O operation, the Linux kernel must allocate internal data structures to represent each segment. *Normally, this allocation occurs dynamically*, based on the size of count. As an optimization, however, the Linux kernel creates a small array of segments on the stack that it uses if count is sufficiently small(Less than 8), negating the need to dynamically allocate the segments and thereby providing a small boost in performance.

** Event Poll
[[man:epoll(7)]]
Both =poll()= and =select()= require the full list of file descriptors(fixed) to watch on each invocation. When this list grows large walking the list on each invocation becomes a scalability bottleneck.
Epoll circumvents this problem by decoupling the monitor registration from the actual monitoring.

*** Creating a New Epoll Instance
[[man:epoll_create1(2)]]
#+BEGIN_SRC C
  int epfd;
  epfd = epoll_create1(0);
  if (epfd < 0) {
    perror("epoll_create1");
  }
#+END_SRC

*** Controlling Epoll
[[man:epoll_ctl(2)]]

*** Waiting for Events with Epoll
[[man:epoll_wait(2)]]

*** TODO Edge-Versus Level-Triggered Events

** Mapping Files info Memory
[[man:mmap(2)]]
The =mmap()= system call operates on pages. Both the addr and offset parameters must be aligned on a page-sized boundary.

*** Resizing a Mapping
man:mremap(2)

*** Changing the Protection of a Mapping
man:mprotect(2)

*** Synchronizing a File with a Mapping
man:msync(2)
Without invocation of =msync()=, there is no guarantee that a dirty mapping will be written back to disk until the file is unmapped.

*** Giving Advice on a Mapping
man:madvise(2)

** Advice for Normal File I/O
man:posix_fadvise(2)
man:readahead(2)

** Synchronized, nonsynchronized or Synchronous, Asynchronous Operations
#+CAPTION: Synchronicity of write operations
|              | Synchronized                                   | Nonsynchronized                                |
|--------------+------------------------------------------------+------------------------------------------------|
| Synchronous  | Write operations do not return until the       | Write operations do not return until the data  |
|              | data is flushed to disk. This is the behavior  | is stored in kernel buffers. This is the usual |
|              | if =O_SYNC= is specified during file open      | behavior                                       |
| Asynchronous | Write operations return as soon as the request | Write operations return as soon as the request |
|              | is queued. Once the write operation ultimately | is queued. Once the write operation ultimately |
|              | executes, the data is guaranteed to be on disk | executes, the data is guaranteed to at least   |
|              |                                                | be stored in kernel buffers.                   |


#+CAPTION: Synchronicity of read operations
|              | Synchronized                                                          |
|--------------+-----------------------------------------------------------------------|
| Synchronous  | Read operations do not return until the data, which is up-to-date,    |
|              | is stored in the provided buffer(this is the usual behavior).         |
| Asynchronous | Read operations return as soon as the request is queued, but when the |
|              | read operation ultimately executes, the data returned is up-to-date   |

*** Asynchronous I/O
man:aio(7)

** I/O Schedulers and I/O Performance
*** The Life of an I/O Scheduler
I/O schedulers perform two basic operations: merging and sorting.
- =Merging=: is the process of taking two or more adjacent I/O requests and combining them into a single request.
- =Sorting=: is the process of arranging pending I/O requests in ascending block order.

*** Helping Out Reads
- =read latency= problem:
- =write-starving-reads= problem:

**** The Deadline I/O Scheduler

**** The Anticipatory I/O Scheduler
**** The CFQ I/O Scheduler
**** The Noop I/O Scheduler
*** Selecting and Configuring Your I/O Scheduler
*** Optimizing I/O Performance
* Process Management
** The Process ID
- The =idle process=: the kernel "runs" when there are no other runnable process, has the pid 0.
- The =init process=: the kernel executes after booting the system, has the pid 1.

Unless the user explicitly tells the kernel what process to run(through the init kernel command-line parameter), the kernel has to identify a suitable init process on its own --- a rare example where the kernel dictates policy. The Linux kernel tries four executables, in the following order:
1. =/sbin/init=: The preferred and most likely location for the init process.
2. =/etc/init=: Another likely location for the init process.
3. =/bin/init=: A fallback location for the init process.
4. =/bin/sh=: The location of the Bourne shell, which the kernel tries to run if it fails to find an init process.

The first of these process that exists is executed as the init process. If all four processes fail to execute, the Linux kernel halts the system with a panic.

*** Process ID Allocation
- By default, the kernel imposes a maximum process ID value of 32768.
- System administrators can set the value higher via =/proc/sys/kernel/pid_max=.

*** Obtaining the Process ID and Parent Process ID
man:getpid(2)
man:getppid(2)

** Running a New Process
- =executing=: the act loads a binary program into memory, replacing the previous contents of the address space, and begins execution of the new program.
- =forking=: the act create a new process which initially is a near-duplicate of its parent process, and then an exec to load a new binary int o that process---are thus required to execute a new program in a new process.

*** The Exec Family of Calls
man:exec(3)
A successful =execl()= call changes not only the address space and process image, but certain other attributes of the process:
- Any pending signals are lost.
- Any signals that the process is catching are returned to their default behavior, as the signal handlers no longer exist in the process's address space.
- Any memory locks are dropped.
- Most thread attributes are returned to the default values.
- Most process statistics are reset.
- Anything related to the process's memory address spaces, including any mapped files, is cleared.
- Anything that exists solely in user spaces, including feature of the C library, such as =atexit()= behavior, is cleared.

*** The fork() System Call
The child and the parent process are identical in nearly every facet, except for a few necessary differences:
- The pid of the child is, of course, newly allocated and different from that of the parent.
- The child's parent pid is set to the pid of its parent process.
- Resource statistics are reset to zero in the child.
- Any pending signals are cleared and not inherited by the child.
- Any acquired file locks are not inherited by the child.

** Terminalting a Process
man:exit(2)
Before terminating the process, the C library performs the following shutdown steps, in order:
1. Call any functions registered with =atexit()= or =on_exit()=, in the reverse order of their registration.
2. Flush all open standard I/O streams.
3. Remove any temporary files created with the =tmpfile()= function.
These steps finish all the work the process needs to do in user space, so =exit()= invokes the system call =_exit()= to let the kernel handle the rest of the termination process.
When a process exits, the kernel cleans up all of the resources that it created on the process's behalf that are no longer in use. The includes, but is not limited to, allocated memory, open files and System V semaphores. After cleanup, the kernel destroys the process and notifies the parent of its child's demise.

man:atexit(3) and man:on_exit(3): used to register functions to be invoked upon process termination
- If a process invokes an exec function, the list of registered functions is cleared.
- If a process terminates via a signal, the registered functions are not called.
- support at least =ATEXIT_MAX= registered functions.

** Waiting for Terminated Child Processes
=zombie= state: when a child dies before its parent. Only a minimal skeleton of what was once the process---some basic kernel data structures containing potentially useful data---is retained. 
A process in this state waits for its parent to inquire about its status(a procedure known as waiting on the zombie process). Only after the parent obtains the information preserved about the terminated child does the process formally exit and cease to exist even as a zombie.

- man:wait(2)
- man:waitpid(2):waiting for a specific process
- man:waitid(2): is used to wait for and obtain information about the status change(termination, stopping, continuing) of a child process.
- man:wait3(2): wait for process to change state

man:system(3): exec shell command
During execution of the command, =SIGCHLD= is blocked, and =SIGINT= and =SIGQUIT= are ignored. Ignoring =SIGINT= and =SIGQUIT= has several implications, particularly if =system()= is invoked inside a loop. If calling =system()= from within a loop, you should ensure that the program properly checks the exit status of the child

** User and Groups
- =Real user ID=: is the uid of the user who originally ran the process. It is set to the real user ID of the process's parent, and does not change during an exec call.
- =effective user ID=: the user ID that the process is currently wielding. Permission verifications normally check against this value. *by executing a setuid(suid) binary, the process can change its effective user ID. To be exact, the effective user ID is set to the user ID of the owner of the program file.*
- =saved user ID=: is the process's original effective user ID.
The effective user ID is the value that matters: it's the user Id that is checked in the course of validating a process's credentials.
The real user ID and saved user ID act as surrogates or potential user ID values that nonroot processes are allowed to switch to and from.
The real user ID is the effective user ID belonging to the user actually running the program, and the saved user ID is the effective user ID from before a suid binary caused a change during exec.

- changing the real or saved user or group id
  man:setuid(2)
  man:setgid(2)
  man:setreuid(2)
  man:setregid(2)
  man:setresuid(2)
  man:setresuid(2)
  Nonroot processes should use =seteuid()= to change their effective user IDs. Root processes should use =setuid()= if they wish to change all three user IDs and =seteuid()= if they wish to temporarily change just the effective user ID.
- obtaining the user and group ids
  man:getuid(2)/man:geteuid(2)
  man:getgid(2)/man:getegid(2)

** Session and Process Groups
man:setsid(2): creates a new session, assuming that the process is not already a process group leader. The calling process is made the session leader and sole member of the new session, which has no controlling tty.

** Daemons
man:daemon(7)
man:daemon(3)
A daemon is a process that runs int the background, not connecting to any controlling terminal.
In general, a program performs the following steps to become a daemon:
1. Call =fork()=. This creates a new process, which will become the daemon.
2. In the parent, call =exit()=. This ensures that the original parent(the daemon's grandparent) is satisfied that its child terminated, that the daemon's parent is no longer running, and that the daemon is not a process group leader. This last point is a requirement for the successful completion of the next step.
3. Call =setsid()=, giving the daemon a new process group and session, both of which have it as leader. This also ensures that the process has no associated controlling terminal(as the process just created a new session and will not assign one).
4. Change the working directory to the root directory via =chdir()=. This is done because the inherited working directory can be anywhere on the filesystem. Daemons tend to run for the duration of the system's uptime, and you don't want to keep some random directory open and thus prevent an administrator from unmounting the filesystem containing that directory.
5. Close all file descriptors. You do not want tot inherit open file descriptors, and, unaware, hold them open.
6. Open file descriptors 0, 1, and 2 and redirect them to =/dev/null=.
* Advanced Process Management
** Yielding the Processor
man:sched_yield(2)
** Process Priorities
- man:nice(2): Passing 0 for inc is an easy way to obtain the current nice value.
- man:getpriority(2)/man:setpriority(2):
- man:ioprio_get(2)/man:ioprio_set(2): 

** Processor Affinity
man:sched_getaffinity(2)
man:sched_setaffinity(2)

** Resource Limits
=resource limits=: place hard ceilings on the amount of kernel resources that a process can consume---that is, the number of open files, pages of memory, pending signals, and so on.
man:getrlimit(2)
man:setrlimit(2)

#+caption: Default soft and hard resource limits
| RLIMIT_AS         | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_CORE       | 0                    | RLIM_INFINITY        |
| RLIMIT_CPU        | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_DATA       | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_FSIZE      | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_LOCKS      | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_MEMLOCK    | 8 pages              | 8 pages              |
| RLIMIT_MSGQUEUE   | 800 KB               | 800 KB               |
| RLIMIT_NICE       | 0                    | 0                    |
| RLIMIT_NOFILE     | 1024                 | 1024                 |
| RLIMIT_NPROC      | 0 (implies no limit) | 0 (implies no limit) |
| RLIMIT_RSS        | RLIM_INFINITY        | RLIM_INFINITY        |
| RLIMIT_RTPRIO     | 0                    | 0                    |
| RLIMIT_SIGPENDING | 0                    | 0                    |
| RLIMIT_STACK      | 8 MB                 | RLIM_INFINITY        |
* Threading
- man:pthread_create(3)
- man:pthread_self(3): obtain TID(thread ID)
- man:pthread_equal(3)
- man:pthread_exit(3): terminating yourself
- man:pthread_cancel(3): terminating others
  return success is only demonstrative of successfully processing the cancellation request. The actual termination occurs asynchronously
  - man:pthread_setcancelstate(3)/man:pthread_setcanceltype(3): set cancelability state and type
- man:pthread_join(3): Joining allows one thread to block while waiting for the termination of another.
- man:pthread_detach(3): 

** Pthread Mutexes
- initializing mutexes:
  #+BEGIN_SRC C
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZAER
  #+END_SRC
- locking mutexes: man:pthread_mutex_lock(3)
- unlocking mutexes: man:pthread_mutex_unlock(3)
* File and Directory Management

