[[file:~/resources/os/book/linux_program/linux_system_programming_2nd_edition.pdf][linux programming]]

* File I/O
** File Descriptors
A file descriptor is a non-negative integer. When we want to read or write a file, we
identify the file with the file descriptor that was returned by =open= or =creat= as an
argument to either =read= or =write=.

By convention, UNIX System shells associate file descriptor:
- 0(=STDIN_FILENO=): the standard input of a process
- 1(=STDOUT_FILENO=): the standard output of a process
- 2(=STDERR_FILENO=): the standard error of a process

File descriptors range from 0 through =OPEN_MAX - 1=.
** Opening Files
[[man:open(2)][open(2)]]
*** =open= and =openat= Functions
A file is opened or created by calling either the =open= function or the =openat= function.
#+BEGIN_SRC C
  #include <fcntl.h>
  #include <sys/types.h>
  #include <sys/stat.h>

  int open(const char *path, int oflag, ... /* mode_t mode */ );
  int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );
  // Both return: file descriptor if OK, âˆ’1 on error
#+END_SRC

- =path=: the name of the file to open or create
  - =open=: absolute pathname
  - =openat=: relative pathname
- =oflag=: determines the type of access used, the prefix name is O_* (e.g. =O_RDONLY, O_WRONLY_O_RDWR=)
- =mode_t=: provide the permissions of the newly created file 
- *return*: the file descriptor returned by =open= and =openat= is guaranteed to be the lowest-numbered unused descriptor
- =fd=: is a file descriptor or =AT_FDCWD=
  - file descriptor: specifies the starting location in the file system where the relative pathname is to be evaluated. It is obtained by opening the directory where the relative pathname is to be evaluated.
  - =AT_FDCWD=: current working directory

** Reading
[[man:read(2)]]

size limits on =read=: According to POSIX.1, if count is greater than =SSIZE_MAX=, the result is implementation-defined

** Writing
[[man:write(2)]]
When a user-space application issues a =write()= system call, the Linux kernel performs a few checks and the simply copies the dada into a buffer. Later, in the background, the kernel fathers up all of the dirty buffer, which are buffers that contain data newer than what is on disk, sorts them optimally and writes them out to dist(a process known as *writeback*)

delayed writes has the following problem
- an application may believe that a write has occurred successfully, in the event of a system crash, the data will never make it to disk
- the inability to enforce *write ordering*
- Any I/O error that occurs during writeback cannot be reported back to the process that issued the write request

To ensure that data is written out in a timely manner, the kernel institutes a *maximum buffer age* and write out all dirty buffers before they mature past the given value. Users can configure this value via =/proc/sys/vm/dirty_expire_centisecs= (one hundredths of a second)

** Synchronized I/O
<<synchronized_I/O>>
[[man:fsync(2)]]
=fdatasync= is similar to =fsync=, but does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be  correctly handled, *so =datasync= is an easy performance win*.

Neither function guarantees that any updated directory entries containing the file are synchronized to disk. To ensure that any updates to the directory entry are also committed to disk, =fsync= must also be called on a file descriptor opened against the file's directory.

[[man:sync(2)]]
commit filesystem caches to disk

oflag:
- =O_SYNC=: an implicit =fsync=, but performance lower than =fsync=
- =O_DSYNC=: an implicit =fdatasync=, but performance lower than =fdatasync=
- =O_RSYNC=: 

** Direct I/O
Providing the =O_DIRECT= flag to =open()= instructs the kernel to minimize the presence of I/O management. When this flag is provided, I/O will initiate directly from user-space buffers to the device, bypassing the page cache. All I/O will be synchronous; operations will not return until completed.

When performing direct I/o, the request length, buffer alignment, and file offsets must all be integer multiples of the underlying device's sector size---generally, this is 512 bytes. To remain compatible, applications should align to the larger logical block size.

** Closing Files
[[man:close(2)]]
After a program has finished working with a file descriptor, it can unmap the file descriptor from the associated file via the =close()= system call.

Note: Typically, filesystem do not flush buffers when a closed. If you need to be sure that the data is physically stored on the underlying disk, use [[synchronized_I/O]]

** Seeking
[[man:lseek(2)]]

Seeking past the end of a file dose nothing
- read request: return =EOF=
- write request: new space will be created between the old length of the file and the new length, and it will be padded with zeros.
  This zero padding is called a *hole*. On Unix-style filesystems, holes do not occupy any physical disk space. This implies that This implies that the total size of all files on a file system can add up to more than the physical size of the disk. Files with holes are called *spares files*. Sparse files can save considerable space and enhance performance because manipulating the holes dose not initiate any physical I/O.
  A read request to the part of a file in a hole will return the appropriate number of zeros.

** Positional Reads and Writes
[[man:pread(2)]]
- these calls are easier to use
- they do note update the file pointer upon completion
- they avoid any potential races that might occur when using =lseek= (e.g., race conditions can be avoided )

** Truncating Files
[[man:truncate(2)]]

** Multiplexed I/O
[[man:select(2)]]
[[man:poll(2)]]

* Buffered I/O
- block is an abstraction representing the smallest unit of storage on a filesystem. Inside the kernel, all filesystem operations occur in terms of blocks.
- =user-buffer I/O=: a way for applications to read and write data in whatever amounts fell natural but have the actual I/O occur in units of the filesystem block size.
- block size: blocks are usually 512, 1024, 2048, 4096, or 8192 bytes in size.

** Opening Files
[[man:fopen(3)]]
** Closing Streams
[[man:fclose(3)]]
[[man:fcloseall(3)]]

** Reading from a Stream
[[man:fgetc(3)]]
[[man:fread(3)]]

** Writing to a Stream
[[man:fputc(3)]]
[[man:fwrite(3)]]

** Seeking a Stream
[[man:fseek(3)]]
** Flushing a Stream
[[man:fflush(3)]]
=fflush()= merely writes the user-buffered data out to the kernel buffer. The effect is the same as if user buffer was not employed and write() was used directly.
So, For writing user-buffered directly to the hard disk, you can call =fflush()=, followed immediately by =fsync()=.

** Errors and End-of-file
[[man:ferror(3)]]

** Obtaining the Associated File Descriptor
[[man:fileno(3)]]

** Controlling the Buffering
[[man:setbuf(3)]]
Standard I/O implements three types of user buffering and provides developers with an interface for controlling the type and size of the buffer.
- Unbuffered(=_IONBF=): No user buffering is performed.
  Date is submitted directly to the kernel. As this disables user buffering, negating any benefit, this option is not commonly used, with a lone exception: standard error, by default, is unbuffered.
- Line-buffered(=_IOLBF=):  Buffering is performed on a per-line basis.
  *With each newline character, the buffer is submitted to the kernel*. Line buffering makes sense for streams being output to the screen, since messages printed to the screen are delimited with newlines.
- Block-buffered(=_IOFBF=): Buffering is performed on a per-block basis, where a block is a fixed number of bytes.
  By default, all streams associated with files are block-buffered. Standard I/o uses the term full buffering for block buffering.

Note:
=setvbuf=: 
- must be called after opening the stream but before any other operations have been performed  on it.
- The supplied buffer, if any, must exits when the stream is closed. A common mistake is to declare the buffer as an automatic variable in a scope that ends before the stream is closed.

** Thread Safety
The standard I/o functions are inherently thread-safe.

*** Manual File Locking
[[man:flockfile(3)]]

*** Unlocked Stream Operations
[[man:unlocked_stdio(3)]]
There is a second reason or performing manual locking on streams. With the finergrained and more precise control of locking that only the application programmer can provide, it might be possible to minimize the over head of locking and to improve performance.

** Critiques of Standard I/O
* Advanced File I/O
** Scatter/gather I/O
Allows a single call to read from or write data to many buffers at once; useful for bunching together fields of different data structures to from one I/O transaction.
[[man:readv(2)]]

optimizing the count:
During a vectored I/O operation, the Linux kernel must allocate internal data structures to represent each segment. *Normally, this allocation occurs dynamically*, based on the size of count. As an optimization, however, the Linux kernel creates a small array of segments on the stack that it uses if count is sufficiently small(Less than 8), negating the need to dynamically allocate the segments and thereby providing a small boost in performance.

** Event Poll
[[man:epoll(7)]]
Both =poll()= and =select()= require the full list of file descriptors(fixed) to watch on each invocation. When this list grows large walking the list on each invocation becomes a scalability bottleneck.
Epoll circumvents this problem by decoupling the monitor registration from the actual monitoring.

*** Creating a New Epoll Instance
[[man:epoll_create1(2)]]
#+BEGIN_SRC C
  int epfd;
  epfd = epoll_create1(0);
  if (epfd < 0) {
    perror("epoll_create1");
  }
#+END_SRC

*** Controlling Epoll
[[man:epoll_ctl(2)]]

*** Waiting for Events with Epoll
[[man:epoll_wait(2)]]

*** TODO Edge-Versus Level-Triggered Events

** Mapping Files info Memory
[[man:mmap(2)]]
The =mmap()= system call operates on pages. Both the addr and offset parameters must be aligned on a page-sized boundary.

*** Resizing a Mapping
man:mremap(2)

*** Changing the Protection of a Mapping
man:mprotect(2)

*** Synchronizing a File with a Mapping
man:msync(2)
